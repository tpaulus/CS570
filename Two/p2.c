//:// Created by Tom Paulus on 2/22/18.// CS 570 -- Carroll// Due: 2/28/2018 11 PM//#include <signal.h>#include <stdlib.h>#include <string.h>#include <sys/types.h>#include <sys/wait.h>#include <unistd.h>#include <fcntl.h>#include "p2.h"#include "getword.h"#define TRUE 1#define FALSE 0//#define DEBUG// Constantsconst int FOUT_FLAGS = O_CREAT | O_EXCL | O_APPEND | O_WRONLY;const int FIN_FLAGS = O_RDONLY;// Line FLagsint FLAG_EOF = FALSE;           // EOFint FLAG_COMMENT = FALSE;       // #int FLAG_DETACH = FALSE;        // &int FLAG_PIPE = FALSE;          // |int FLAG_OUT_REDIR = FALSE;     // >int FLAG_IN_REDIR = FALSE;      // <// Globalschar *input_file = NULL;char *output_file = NULL;char *pipe_location = NULL;char s[STORAGE];char *parsed_line[MAXITEM];int main() {    int line_length;    setpgid(0, 0);    (void) signal(SIGTERM, signal_handler);    for (;;) {        init();        line_length = parse_line(parsed_line); // Let input from command line        if (FLAG_EOF) break;  // EOF received from input        if (line_length == 0) continue;  // Empty Line        if (builtin_handler(parsed_line, line_length) == 1) continue;        else if (!FLAG_PIPE) exec_simple(parsed_line, line_length);        // TODO Piped Executions    }    killpg(getpgrp(), SIGTERM);    printf("p2 terminated.\n");    exit(0);}void init() {    printf("p2: ");    // Reset Args Array    memset(&parsed_line, 0, sizeof parsed_line);    // Reset Flags    FLAG_EOF = FALSE;    FLAG_COMMENT = FALSE;    FLAG_DETACH = FALSE;    FLAG_PIPE = FALSE;    FLAG_OUT_REDIR = FALSE;    FLAG_IN_REDIR = FALSE;    // Reset Pipes    input_file = NULL;    output_file = NULL;    pipe_location = NULL;}int parse_line(char *args[]) {    int word_length;    char *s_prt = s;    int input_length = 0; // Number of words entered by the user    word_length = getword(s_prt); // Get first word    while (word_length != 0 && word_length != -10) {        if (word_length < 0) {            // Meta Characters            if (*s_prt == '#') FLAG_COMMENT = TRUE;            else if (*s_prt == '>') {                // Next Argument will be the Destination File                FLAG_OUT_REDIR = TRUE;                word_length = getword(s_prt);                continue;            } else if (*s_prt == '<') {                // Next Argument will be the Input File                FLAG_IN_REDIR = TRUE;                word_length = getword(s_prt);                continue;            } else if (*s_prt == '|') {                FLAG_PIPE = TRUE;                // Save pipe location                pipe_location = s_prt;                s_prt += abs(word_length + 1);                word_length = getword(s_prt);                continue;            } else if (*s_prt == '&') {                FLAG_DETACH = TRUE;                break;            }        }        if (FLAG_OUT_REDIR && output_file == NULL) {            output_file = s_prt;            s_prt += abs(word_length + 1);            word_length = getword(s_prt);            continue;        }        if (FLAG_IN_REDIR && input_file == NULL) {            input_file = s_prt;            s_prt += abs(word_length + 1);            word_length = getword(s_prt);            continue;        }        // Parse Regular Arguments        args[input_length] = s_prt; // Save Input Word        s_prt += abs(word_length + 1); // Move Input Buffer Pointer        input_length++; // Increment the Argument Counter        word_length = getword(s_prt); // Get next word    }    if (word_length == 0) FLAG_EOF = TRUE; // EOF Received    return !FLAG_COMMENT ? input_length : 0; // Return Length 0 if comment line}void exec_simple(char **args, int arg_len) {    int input_fd = -1;    int output_fd = -1;#ifdef DEBUG    int i;    printf("%d arguments - ", arg_len);    for (i = 0; i < sizeof(args); ++i) {        printf("%s, ", args[i]);    }    printf("\n");#endif    if (FLAG_DETACH && !FLAG_IN_REDIR) {        // Redirect Input to /dev/null for Detached Child        FLAG_IN_REDIR = TRUE;        input_file = "/dev/null";    }    if (FLAG_IN_REDIR) {        if ((input_fd = open(input_file, FIN_FLAGS, S_IRUSR | S_IWUSR)) < 0) {            perror("Could not set input redirection file");            return;        }    }    if (FLAG_OUT_REDIR) {        if ((output_fd = open(output_file, FOUT_FLAGS, S_IRUSR | S_IWUSR)) < 0) {            perror("Could not set output redirection file");            return;        }    }    // Forking a child    fflush(stdout);    pid_t child_pid = fork();    if (child_pid == -1) {        printf("\nFailed forking child.\n");        return;    } else if (child_pid == 0) {        // This is run by the child process        if (FLAG_IN_REDIR)dup2(STDIN_FILENO, input_fd);        if (FLAG_OUT_REDIR) dup2(output_fd, STDOUT_FILENO);        if (execvp(args[0], args) < 0) {            printf("Could not execute command %s.\n", args[0]);            exit(9);        }        exit(0);    } else if (!FLAG_DETACH) {        // Wait for forked child process to complete if process is attached to parent        pid_t completed_child = 0;        while (completed_child != child_pid) {            completed_child = wait(NULL);        }    } else {        // Print PID for child task        printf("%s [%d]", args[0], child_pid);    }    if (input_fd != -1) close(input_fd);  // fixme check for close return status    if (output_fd != -1) close(output_fd); // fixme check for close return status}void execPiped(char **args, char **parsedpipe, int arg_len) {    // TODO}int builtin_handler(char **args, int arg_len) {    int NoOfBuiltinCmds = 4, i, switchBuiltinArg = 0;    char *ListOfBuiltinCmds[NoOfBuiltinCmds];    ListOfBuiltinCmds[0] = "exit";    ListOfBuiltinCmds[1] = "cd";    ListOfBuiltinCmds[2] = "MV";    ListOfBuiltinCmds[3] = "help";#ifdef DEBUG    int j;    printf("%d arguments - ", arg_len);    for (j = 0; j < arg_len; ++j) {        printf("%s, ", args[j]);    }    printf("\n");#endif    for (i = 0; i < NoOfBuiltinCmds; i++) {        if (strcmp(args[0], ListOfBuiltinCmds[i]) == 0) {            switchBuiltinArg = i + 1;            break;        }    }    switch (switchBuiltinArg) {        case 1:            printf("\nGoodbye!\n");            exit(0);        case 2:            if (arg_len < 2) chdir(getenv("HOME"));            else chdir(args[1]);            return 1;        case 3:            mv(args[1], args[2]);            return 1;        case 4:            openHelp();            return 1;        default:            break;    }    return 0;}void openHelp() {    printf("\n***WELCOME TO P2 SHELL HELP***"                   "\n-Use the shell at your own risk..."                   "\nList of Builtin Commands supported:"                   "\n>cd"                   "\n>MV"                   "\n>exit"                   "\n>all other general commands available in UNIX shell"                   "\n>pipe handling"                   "\n>improper space handling\n");}void mv(char *source, char *destination) {#ifdef DEBUG    printf("Source - %s\n", source);    printf("Destination - %s\n", destination);#endif    if (link(source, destination) == 0) {        unlink(source);    } else {        printf("Cannot move file - cannot establish link\n");    }}void signal_handler(int signum) {    printf("Received SIGTERM (%d), and the special handler is running...\n", signum);}